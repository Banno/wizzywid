<link rel="import" href="../bower_components/polymer/polymer-element.html">

<dom-module id="code-view">
  <template strip-whitespace>
    <style>
      :host {
        display: block;
      }

      #__editor {
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: relative;
      }
    </style>
    <div id="__editor"></div>
  </template>
  <script>
    class CodeView extends Polymer.Element {
      static get is() { return 'code-view'; }

      // Yeah so Ace editor doesn't work with shadow roots because
      // it probably does a document.getElementById in the edit function.
      _attachDom(dom) {
        return this.appendChild(dom);
      }

      connectedCallback() {
        super.connectedCallback();
        this._propertyDefaultsForTag = {};

        this._aceEditor = ace.edit('__editor');
        this._aceEditor.setReadOnly(true);
        this._aceEditor.setTheme("ace/theme/monokai");
        this._aceEditor.getSession().setMode("ace/mode/html");
        this._aceEditor.$blockScrolling = Infinity;
        this._aceEditor.setOptions({fontSize: "14px"});
      }

      update(code) {
        this._aceEditor.setValue(code);
        this._aceEditor.clearSelection();
      }

      has(tag) {
        return !!this._propertyDefaultsForTag[tag];
      }

      save(tag, packageName, el, props) {
        if (this._propertyDefaultsForTag[tag]) {
          return;
        }

        this._propertyDefaultsForTag[tag] = {};
        this._propertyDefaultsForTag[tag]['__package_name__'] = packageName;

        let keys = ['id', 'slot', 'classList'].concat(props);
        for (let i = 0; i < keys.length; i++) {
          let prop = keys[i];
          if (prop === 'classList') {
            this._propertyDefaultsForTag[tag][prop] = el[prop].value;
          } else {
            this._propertyDefaultsForTag[tag][prop] = el[prop];
          }
        }
      }

      get(parent) {
        // Imports. Yes i'm using element globals because I'm lazy. Fight me.
        this._imports = '';
        this._template = '';
        this._style = '';

        // Host styles.
        let hostCss = parent.style.cssText.replace(/;/g, `;\n       `).trim();
        let bonusHost = `        ${hostCss}`;

        this.dumpChildren(parent, '    ');

        let domModule = `
<dom-module id="main-app">
  <template>
    <style>
      :host {
        position: absolute;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
${bonusHost.trimRight()}
      }
${this._style.trimRight()}
    </style>
${this._template.trimRight()}
  </template>
  <script>
    class MainApp extends Polymer.Element {
      static get is() { return 'main-app'; }
    }
    customElements.define(MainApp.is, MainApp);
  &lt;/script>
</dom-module>`;
        let appTitle = 'wizzywid output';
        let html = `<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">
<title>${appTitle}</title>
<base href="https://polygit.org/polymer+:master/webcomponents+:master/shadycss+webcomponents+:master/paper*+polymerelements+:master/iron*+polymerelements+:master/app*+polymerelements+:master/neon*+polymerelements+:master/components/">
<script src="webcomponentsjs/webcomponents-lite.js">&lt;/script>
<link rel="import" href="polymer/polymer-element.html">
${this._imports.trimRight()}
<style>
  body {
    margin: 0;
    font-family: 'Roboto', 'Noto', sans-serif;
    line-height: 1.5;
    background-color: white;
  }
</style>
</head>
<body>

<main-app></main-app>

${domModule}
</body>
</html>`;
        return html.replace(/&lt;/g, '<');
      }

      dump(parent) {
        this.update(this.get(parent));
      }

      dumpChildren(parent, indent) {
        let nodes = parent.children;

        for (let i = 0; i < nodes.length; i++) {
          // Add to the import if needed.
          let tag = nodes[i].tagName.toLowerCase();

          if (tag === 'style') {
            // Need to indent it
            this._style += nodes[i].textContent.replace(/[\n\r]/g, '\n    ') + '\n';
            continue;
          }

          if (tag.indexOf('-') !== -1 && this._imports.indexOf(`${tag}.html`) === -1) {
            this._imports += this.dumpImports(tag, '') + '\n';
          }
          this._style += this.dumpStyle(tag, nodes[i], '      ');

          // If this element doesn't have children, do it on one line.
          if (nodes[i].children.length == 0) {
            this._template += this.dumpElementStartTag(tag, nodes[i], indent);
            this._template += this.dumpElementText(tag, nodes[i], '');
            this._template += this.dumpElementEndTag(tag, nodes[i], '') + '\n';
          }
          else {
            this._template += this.dumpElementStartTag(tag, nodes[i], indent) + '\n';
            this.dumpChildren(nodes[i], indent + '  ') + '\n';
            this._template += this.dumpElementEndTag(tag, nodes[i], indent) + '\n';
          }
        }
      }

      dumpElementText(tag, node, indent) {
        let text = node.textContent.trim();
        if (text && node.children.length === 0) {
          return `${indent}${text}`
        } else {
          return '';
        }
      }
      dumpElementStartTag(tag, node, indent) {
        let attributes = this.dumpAttributes(tag, node);
        return attributes.length === 0 ?
            `${indent}<${tag}>` :
            `${indent}<${tag} ${attributes}>`;
      }

      dumpElementEndTag(tag, node, indent) {
        return tag === 'input' ? '' : `${indent}</${tag}>`;
      }

      dumpStyle(tag, node, indent) {
        let css = node.style.cssText.replace(/;/g, `;\n${indent} `).trim();
        if (css === '') {
          return '';
        }
        let id = node.id ? '#' + node.id : '';
        return `${indent}${tag}${id} {
${indent}  ${css}
${indent}}
`
      }

      dumpAttributes(tag, node) {
        if (!this._propertyDefaultsForTag[tag]) {
          this._doDefaultPropsForUnseenTag(tag);
        }
        let defaults = Object.keys(this._propertyDefaultsForTag[tag]);
        let attributes = ' ';
        for (let i = 0; i < defaults.length; i++) {
          let name = defaults[i];
          let value = node[name];

          if (name === '__package_name__') {
            continue;
          } else if (name === 'classList') {
            // classList is special. Also 'active' is an internal value, so skip that.
            value = value.value; // classList is an array, surprise!
            value = value.replace('active', '').trim();
            if (value.length !== 0) {
              attributes += `class="${value}" `
            }
          } else if (value === true) {
            attributes += `${name} `;
          } else if (this._propertyDefaultsForTag[tag][name] != value) {
            attributes += `${name}="${value}" `
          }
        }
        return attributes.trim();
      }

      dumpImports(tag, indent) {
        if (!this._propertyDefaultsForTag[tag]) {
          this._doDefaultPropsForUnseenTag(tag);
        }
        let packageName = this._propertyDefaultsForTag[tag]['__package_name__'];
        // If this is app-layout stuff, it needs an extra package name.
        if (packageName === 'app-header' || packageName === 'app-drawer' || packageName === 'app-toolbar') {
          packageName = 'app-layout/' + packageName;
        }

        // PS: this should be ../${packageName}/${tag}.html if you're
        // not using polygit.
        return `${indent}<link rel="import" href="${packageName}/${tag}.html">`;
      }

      _doDefaultPropsForUnseenTag(tag) {
        let el = document.createElement(tag);
        this.save(tag, tag, el, getProtoProperties(el));
      }
    }
    customElements.define(CodeView.is, CodeView);
  </script>
</dom-module>
