<link rel="import" href="../bower_components/polymer/polymer-element.html">

<dom-module id="code-view">
  <template strip-whitespace>
    <style>
      :host {
        display: block;
      }

      #__editor {
        width: 100%;
        height: 100%;
        overflow: hidden;
        position: relative;
      }
    </style>
    <div id="__editor"></div>
  </template>
  <script>
    class CodeView extends Polymer.Element {
      static get is() { return 'code-view'; }

      // Yeah so Ace editor doesn't work with shadow roots because
      // it probably does a document.getElementById in the edit function.
      _attachDom(dom) {
        return this.appendChild(dom);
      }

      connectedCallback() {
        super.connectedCallback();
        this._propertyDefaultsForTag = {};

        this._aceEditor = ace.edit('__editor');
        this._aceEditor.setReadOnly(true);
        this._aceEditor.setTheme("ace/theme/monokai");
        this._aceEditor.getSession().setMode("ace/mode/html");
        // /this._aceEditor.$blockScrolling = Infinity;
        this._aceEditor.setOptions({fontSize: "14px"});
      }

      update(code) {
        this._aceEditor.setValue(code);
        this._aceEditor.clearSelection();
      }

      save(tag, packageName, el, props) {
        if (this._propertyDefaultsForTag[tag])
          return;

        this._propertyDefaultsForTag[tag] = {};
        this._propertyDefaultsForTag[tag]['__package_name__'] = packageName;

        var keys = ['id', 'slot', 'classList'].concat(props);
        for (var i = 0; i < keys.length; i++) {
          var prop = keys[i];
          if (prop === 'classList') {
            this._propertyDefaultsForTag[tag][prop] = el[prop].value;
          } else {
            this._propertyDefaultsForTag[tag][prop] = el[prop];
          }
        }
      }

      dump(parent) {
        // Imports. Yes i'm using element globals because I'm lazy. Fight me.
        this._imports = '';
        this._template = '';
        this._style = '';

        // Host styles.
        var hostCss = parent.style.cssText.replace(/;/g, `;\n       `).trim();
        var bonusHost = `        ${hostCss}`;

        this.dumpChildren(parent, '    ');

        var boilerplate = `${this._imports.trimRight()}
<dom-module id="main-app">
  <template>
    <style>
      :host {
        position: absolute;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
${bonusHost.trimRight()}
      }
${this._style.trimRight()}
    </style>
${this._template.trimRight()}
  </template>
  <script>
    class MainApp extends Polymer.Element {
      static get is() { return 'main-app'; }
    }
    customElements.define(MainApp.is, MainApp);
  &lt;/script>
</dom-module>`;
        boilerplate = boilerplate.replace(/&lt;/g, '<');
        this.update(boilerplate);
      }

      dumpChildren(parent, indent) {
        var nodes = parent.children;

        for (var i = 0; i < nodes.length; i++) {
          // Add to the import if needed.
          var tag = nodes[i].tagName.toLowerCase();
          if (tag.indexOf('-') !== -1 && this._imports.indexOf(`${tag}.html`) === -1) {
            this._imports += this.dumpImports(tag, '') + '\n';
          }
          this._style += this.dumpStyle(tag, nodes[i], '      ');

          if (nodes[i].children.length !== 0) {
            this._template += this.dumpElementStartTag(tag, nodes[i], indent) + '\n';
            this.dumpChildren(nodes[i], indent + '  ') + '\n';
            this._template += this.dumpElementEndTag(tag, nodes[i], indent) + '\n';
          } else {
            this._template += this.dumpElement(tag, nodes[i], indent) + '\n';
          }
        }
      }

      dumpElement(tag, node, indent) {
        var attributes = this.dumpAttributes(tag, node);
        var text = node.textContent || '';
        var startTag = this.dumpElementStartTag(tag, node, indent);
        return tag === 'input' ?
            startTag :
            startTag + `${text}</${tag}>`
      }

      dumpElementStartTag(tag, node, indent) {
        var attributes = this.dumpAttributes(tag, node);
        return attributes.length === 0 ?
            `${indent}<${tag}>` :
            `${indent}<${tag} ${attributes}>`;
      }

      dumpElementEndTag(tag, node, indent) {
        return `${indent}</${tag}>`;
      }

      dumpStyle(tag, node, indent) {
        var css = node.style.cssText.replace(/;/g, `;\n${indent} `).trim();
        var id = node.id ? '#' + node.id : '';
        return `${indent}${tag}${id} {
${indent}  ${css}
${indent}}
`
      }

      dumpAttributes(tag, node) {
        var defaults = Object.keys(this._propertyDefaultsForTag[tag]);
        var attributes = ' ';
        for (var i = 0; i < defaults.length; i++) {
          var name = defaults[i];
          var value = node[name];

          if (name === '__package_name__') {
            continue;
          } else if (name === 'classList') {
            // classList is special. Also 'active' is an intenal value, so skip that.
            value = value.value; // classList is an array, surprise!
            value = value.replace('active', '').trim();
            if (value.length !== 0) {
              attributes += `class="${value}" `
            }
          } else if (value == true) {
            attributes += `${name} `;
          } else if (this._propertyDefaultsForTag[tag][name] != value) {
            attributes += `${name}="${value}" `
          }
        }
        return attributes.trim();
      }

      dumpImports(tag, indent) {
        var packageName = this._propertyDefaultsForTag[tag]['__package_name__'];
        return `${indent}<link rel="import" href="../${packageName}/${tag}.html">`;
      }
    }
    customElements.define(CodeView.is, CodeView);
  </script>
</dom-module>
