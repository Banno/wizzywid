<link rel="import" href="../bower_components/polymer/polymer-element.html">
<dom-module id="action-history">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
  </template>
  <script>
    /*
     * Manages a stack of available undo/redo actions
     */
    class ActionHistory extends Polymer.Element {
      static get is() { return 'action-history'; }

      constructor() {
        super();
        this.undoHistory = [];
        this.redoHistory = [];
      }

      add(action, node, detail) {
        const item = {
          action: action,
          node: node,
          detail: detail
        };

        // Don't save no-ops: this action may have the new state the same as
        // the old state (like when you start dragging but don't get anywhere)
        if (detail && detail.new && detail.old &&
            this._itemsMatch(action, detail.new, detail.old)) {
          return;
        }

        const topItem = this.undoHistory[this.undoHistory.length - 1];

        // Don't save dupes: this action may be a duplicate of the previous one.
        if (topItem &&
            item.action === topItem.action &&
            topItem.node === item.node &&
            item.detail && topItem.detail &&
            this._itemsMatch(item.action, item.detail, topItem.detail)) {
          return;
        }

        this.undoHistory.push(item);

        // A new item in the undo stack means you have nothing to redo.
        this.redoHistory = [];
        this.updateButtons();
      }

      undo() {
        // Take the top action off the undo stack and move it to the redo stack.
        const item = this.undoHistory.pop();
        this.redoHistory.push(item);
        this.updateButtons();

        const detail = item.detail;
        item.node.click();
        switch(item.action) {
          case 'update':
              Polymer.Base.fire('element-updated',
                  {type: detail.type, name: detail.name, value: detail.old.value, noUpdateHistory: true},
                  {node: this});
              break;
          case 'new':
              this._doEvent(item.node, 'remove-from-canvas');
              break;
          case 'delete':
              if (item.node.id === 'viewContainer') {
                item.node.setInnerHTML(detail.innerHTML);
              } else {
                detail.parent.appendChild(item.node);
              }
              break;
          case 'move':
              this._updatePosition(item.node, detail.old);
              break;
          case 'resize':
              this._updateSize(item.node, detail.old);
              break;
          case 'reparent':
              this._reparent(item.node, detail.new.parent, detail.old.parent);
              this._updatePosition(item.node, detail.old);
              break;
          case 'fit':
              this._updatePosition(item.node, detail.old);
              this._updateSize(item.node, detail.old);
              break;
          case 'move-up':
          case 'move-down':
              this._reparent(item.node, detail.new.parent, detail.old.parent);
              break;
          case 'move-back':
              Polymer.Base.fire('move', {type:'forward'}, {node: this});
              break;
          case 'move-forward':
              Polymer.Base.fire('move', {type:'back'}, {node: this});
              break;
        }
        item.node.click();
      }

      redo() {
        // Take the top action off the redo stack and move it to the undo stack.
        let item = this.redoHistory.pop();
        let detail = item.detail;
        this.undoHistory.push(item);
        this.updateButtons();

        item.node.click();
        switch(item.action) {
          case 'update':
              Polymer.Base.fire('element-updated',
                  {type: detail.type, name: detail.name, value: detail.new.value, noUpdateHistory: true},
                  {node: this});
              break;
          case 'new':
              this._doEvent(item.node, 'add-to-canvas');
              break;
          case 'delete':
              // If the node is the viewContainer, clear its inner HTML.
              if (item.node.id === 'viewContainer') {
                item.node.setInnerHTML('');
              } else {
                item.node.parentElement.click();
                item.node.parentElement.removeChild(item.node);
              }
              break;
          case 'move':
              this._updatePosition(item.node, detail.new);
              break;
          case 'resize':
              this._updateSize(item.node, detail.new);
              break;
          case 'reparent':
              this._reparent(item.node, detail.old.parent, detail.new.parent);
              this._updatePosition(item.node, detail.new);
              break;
          case 'fit':
              this._updateSize(item.node, detail.new);
              this._updatePosition(item.node, detail.new);
              break;
          case 'move-up':
          case 'move-down':
              this._reparent(item.node, detail.old.parent, detail.new.parent);
              break;
          case 'move-back':
              Polymer.Base.fire('move', {type:'forward'}, {node: this});
              break;
          case 'move-forward':
              Polymer.Base.fire('move', {type:'back'}, {node: this});
              break;
        }
        item.node.click();
      }

      updateButtons() {
        Polymer.Base.fire('update-action-buttons',
            {undos: this.undoHistory.length, redos: this.redoHistory.length}, {node: this});
      }

      _itemsMatch(action, first, second) {
        // These kinds of actions have element refs in the details,
        // and you can't json those anyway.
        if (action === 'reparent' || action === 'move-up' || action === 'move-down') {
          return false;
        }
        return JSON.stringify(first) === JSON.stringify(second);
      }

      _doEvent(node, name) {
        Polymer.Base.fire(name, {target: node}, {node: this});
      }

      _updatePosition(node, detail) {
        node.style.left = detail.left;
        node.style.top = detail.top;
        node.style.position = detail.position;
      }

      _updateSize(node, detail) {
        node.style.width = detail.width;
        node.style.height = detail.height;
      }

      _reparent(node, oldParent, newParent) {
        oldParent.removeChild(node);
        newParent.appendChild(node);
      }
    }
    customElements.define(ActionHistory.is, ActionHistory);
  </script>
</dom-module>
