<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">

<dom-module id="canvas-view">
  <template>
    <style>
      :host {
        display: block;
        box-sizing: border-box;
        width: 100%;
        position: relative;
        /* 10px grid, using http://www.patternify.com/ */
        background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAGUlEQVQYV2NkIBIwEqmOYVQh3pAiNnj+AwALaAEKfsPrZgAAAABJRU5ErkJggg==);
        background-position: 0px 0px;
        transform: translateZ(0);
      }
      #canvas > * {
        cursor: pointer;
      }
      .active {
        outline: solid 3px var(--highlight-blue) !important;
        outline-offset: 2px;
      }
      /* Show a resize cursor in the corner */
      .active:after {
        position: absolute;
        bottom: 0;
        right: 0;
        content: '';
        height: 10px;
        width: 10px;
        cursor: se-resize;
      }
      .dragging, .resizing {
        user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
      }
      .dragging {
        opacity: 0.6;
        z-index: 1000;
        cursor: move;
      }
      .resizing {
        cursor: se-resize;
      }
      .over {
        outline: dashed 3px var(--highlight-blue) !important;
        outline-offset: 2px;
      }
    </style>
    <div id="canvas"></div>
  </template>
  <script>
    class CanvasView extends Polymer.Element {
      static get is() { return 'canvas-view'; }
      connectedCallback() {
        super.connectedCallback();

        Polymer.Gestures.addListener(this.$.canvas, 'track', this.trackElement.bind(this));
        this.addEventListener('click', function(event) {
          this.updateActiveElement(this._getRealEventElement(event));
        }.bind(this));

        window.addEventListener('keydown', this.onKeyDown.bind(this), true);
      }

      add(el) {
        this.$.canvas.appendChild(el);
      }
      remove(el) {
        this.$.canvas.removeChild(el);
      }
      has(query) {
        return this.$.canvas.querySelector(query);
      }
      setInnerHTML(thing) {
        this.$.canvas.innerHTML = thing;
      }
      getInnerHTML() {
        return this.$.canvas.innerHTML;
      }
      get children() {
        return this.$.canvas.children;
      }
      updateActiveElement(el) {
        Polymer.Base.fire('selected-element-changed', {target: el}, {node: this});
        Polymer.Base.fire('refresh-view', {}, {node: this});
      }

      _getRealEventElement(event) {
        let el = event.composedPath()[0];

        // You might have clicked on someting inside a shadow root.
        // In that case, select the top most shadow root element.
        let shadowParent = el;
        while (shadowParent !== this) {
          el = shadowParent;
          shadowParent = el.getRootNode().host;
        }
        return el;
      }

      trackElement(event) {
        let el = this._getRealEventElement(event);
        if (el === this) {
          return;
        }
        let rekt = el.getBoundingClientRect();
        let shouldResize = this.dragShouldSize(event, rekt);

        if (shouldResize && !this._resizing) {
          this._resizing = true;
          this._initialWidth = rekt.width;
          this._initialHeight = rekt.height;
          el.classList.add('resizing');
          el.classList.add('active');
        }

        if (this._resizing) {
          this.resizeElement(event, el);
        } else {
          this.dragElement(event, el, rekt);
        }
      }

      dragElement(event, el, rekt) {
        switch(event.detail.state) {
          case 'start':
            el.style.position = 'absolute';
            el.classList.add('dragging');
            el.classList.add('active');
            break;
          case 'track':
            // Grid is 10.
            this._trackx = Math.round(event.detail.dx / 10) * 10;
            this._tracky = Math.round(event.detail.dy / 10) * 10;
            el.style.transform = el.style.webkitTransform =
              'translate(' + this._trackx + 'px, ' + this._tracky + 'px)';

            // See if it's over anything.
            this._dropTarget = null;
            let targets = this.root.querySelectorAll('*');
            for (let i = 0; i < targets.length; i++) {
              let t = targets[i];
              t.classList.remove('over');

              // Only some native elements and things with slots can be
              // drop targets.
              let slots = t.root ? t.root.querySelectorAll('slot') : [];
              let canDrop =
                t.tagName === 'DIV' || t.tagName === 'BUTTON' ||
                t.tagName === 'FORM' ||
                slots.length !== 0;

              if (!canDrop) {
                continue;
              }

              // Do we actually intersect this child?
              let b = t.getBoundingClientRect();
              if (rekt.left > b.left && rekt.left < b.left + b.width &&
                  rekt.top > b.top && rekt.top < b.top + b.height) {
                t.classList.add('over');
                this._dropTarget = t;
              }
            }
            break;
          case 'end':
            this._resizing = false;
            let reparented = false;
            let oldParent = el.parentElement;
            let newParent;
            // Does this need to be added to a new parent?
            if (this._dropTarget) {
              reparented = true;
              oldParent.removeChild(el);

              // If there was a textContent nuke it, or else you'll
              // never be able to again.
              if (this._dropTarget.children.length === 0) {
                this._dropTarget.textContent = '';
              }
              this._dropTarget.appendChild(el);
              this._dropTarget.classList.remove('over');
              newParent = this._dropTarget;
              this._dropTarget = null;
            } else if (el.parentElement && (el.parentElement !== this.$.canvas)) {
              reparented = true;
              // If there's no drop target and the el used to be in a different
              // parent, move it to the main view.
              newParent = this.$.canvas;
              el.parentElement.removeChild(el);
              this.add(el);
            }
            let parent = el.parentElement.getBoundingClientRect();

            let oldLeft = el.style.left;
            let oldTop = el.style.top;
            let oldPosition = el.style.position;
            if (reparented) {
              el.style.position = 'static';
              el.style.left = el.style.top = '0px';
              this.shell.$.actionHistory.add('reparent', el,
                  {
                    new: {
                      parent: newParent,
                      left: el.style.left, top: el.style.top, position: el.style.position
                    },
                    old: {
                      parent: oldParent,
                      left: oldLeft, top: oldTop, position:oldPosition
                    }
                  });
            } else {
              el.style.position = 'absolute';
              el.style.left = rekt.left - parent.left + 'px';
              el.style.top = rekt.top - parent.top + 'px';
              this.shell.$.actionHistory.add('move', el,
                {
                  new:{left: el.style.left, top: el.style.top, position: el.style.position},
                  old:{left: oldLeft, top: oldTop, position:oldPosition}
                });
            }
            el.classList.remove('dragging');
            el.style.transform = el.style.webkitTransform = 'none';
            break;
        }
        this.updateActiveElement(el);
        this.shell.refreshViewWhileTracking();
      }

      resizeElement(event, el) {
        switch(event.detail.state) {
          case 'track':
            // Grid is 10.
            let trackX = Math.round(event.detail.dx / 10) * 10;
            let trackY = Math.round(event.detail.dy / 10) * 10;
            el.style.width = this._initialWidth + trackX + 'px';
            el.style.height = this._initialHeight + trackY + 'px';
            break;
          case 'end':
            this._resizing = false;
            this.shell.$.actionHistory.add('resize', el,
               {
                 new:{width: el.style.width, height: el.style.height},
                 old:{width: this._initialWidth + 'px', height: this._initialHeight + 'px'}
               });
            el.classList.remove('resizing');
            break;
        }
        this.updateActiveElement(el);
      }

      dragShouldSize(event, rect) {
        return (Math.abs(rect.right - event.detail.x) < 10) &&
          (Math.abs(rect.bottom - event.detail.y) < 10);
      }

      deepTargetFind(x, y, notThis) {
        let node = document.elementFromPoint(x, y);
        let next = node;
        // this code path is only taken when native ShadowDOM is used
        // if there is a shadowroot, it may have a node at x/y
        // if there is not a shadowroot, exit the loop
        while (next !== notThis && next && next.shadowRoot && !window.ShadyDOM) {
          // if there is a node at x/y in the shadowroot, look deeper
          let oldNext = next;
          next = next.shadowRoot.elementFromPoint(x, y);
          // on Safari, elementFromPoint may return the shadowRoot host
          if (oldNext === next) {
            break;
          }
          if (next) {
            node = next;
          }
        }
        return node;
      }

      onKeyDown(event) {
        let el = this.shell.activeElement;
        if (!el) {
          return;
        }

        // This is a gloabl window handler, so clicks can come from anywhere
        // We only care about keys that come after you've clicked on an element,
        // or keys after you've selected something from the tree view.
        // TODO: can this be less bad since it's p horrid?
        let isOk = (event.composedPath()[0].tagName === 'BUTTON' && event.composedPath()[2].tagName == 'TREE-VIEW') ||
          (event.composedPath()[0].tagName == 'BODY') || event.composedPath()[0].classList.contains('active');

        if (!isOk) {
          return;
        }
        let oldLeft = parseInt(el.style.left);
        let oldTop = parseInt(el.style.top);
        let oldPosition = el.style.position;

        switch(event.keyCode) {
          case 38:  // up arrow
            if (event.shiftKey) {
              event.preventDefault();
              this.shell.moveUp();
            } else {
              el.style.top = oldTop - 10 + 'px';
            }
            break;
          case 40:  // down arrow
            if (event.shiftKey) {
              event.preventDefault();
              this.shell.moveDown();
            } else {
              el.style.top = oldTop + 10 + 'px';
            }
            break;
          case 37:  // left arrow
            if (event.shiftKey) {
              event.preventDefault();
              this.shell.moveBack();
            } else {
              el.style.left = oldLeft - 10 + 'px';
            }
            break;
          case 39:  // right arrow
            if (event.shiftKey) {
              event.preventDefault();
              this.shell.moveForward();
            } else {
              el.style.left = oldLeft + 10 + 'px';
            }
            break;
        }
        this.shell.$.actionHistory.add('move', el,
            {
              new:{left: el.style.left, top: el.style.top, position: el.style.position},
              old:{left: oldLeft, top: oldTop, position:oldPosition}
            });
      }
    }
    customElements.define(CanvasView.is, CanvasView);
  </script>
</dom-module>
